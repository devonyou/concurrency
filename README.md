# 다중 인스턴스에서 트래픽 부하 및 동시성 테스트

### 🛠 다중 인스턴스에서 트래픽 부하 및 동시성 테스트를 위한 간단한 예제입니다.

**[단일 노드 환경]**

- [Pessimistic Lock](#1-비관적-락-pessimistic-lock)
- [Optimistic Lock](#2-낙관적-락-optimistic-lock)
- [Queue-Based Processing](#3-큐-기반-처리-queue-based-processing)

**[다중 노드 환경]**

- [Redis RedLock Processing](#4-redis-기반-redlock-처리-분산락)
- [RabbitMQ + Redis Processing](#5-rabbitmq-redis-기반-처리)

---

### 시나리오

- **목표**: 동시 예약 요청이 많을 때 시스템이 정상적으로 처리되는지 확인.
- **분산환경**: 개발환경 테스트 편의를 위해 컨테이너 내부에서 PM2 다중 클러스터 이용
- **테스트 조건**:
    - **VUs (Virtual Users)**: 1000명의 가상 사용자가 동시에 티켓 예약 요청을 보냅니다.
    - **Test Duration**: 5초 동안 요청을 처리합니다.
    - **Metric**: `HTTP 응답 코드`, `응답 시간`, `성공률` 등

```sh
> k6 run overbook.js --out json=overbook-result.json
```

```sh
# swagger
> http://localhost/api-docs

# bullmq dashboard
> http://localhost/queues
```

---

## 1. 비관적 락 (Pessimistic Lock)

### 개념

- **[단일노드]**
- **데이터를 조회하는 순간 락을 걸어 다른 트랜잭션이 접근하지 못하도록 하는 방식**
- 동시에 여러 요청이 들어오더라도 하나씩 순차적으로 처리됨
- `SELECT ... FOR UPDATE` 같은 쿼리를 사용하여 트랜잭션 동안 데이터가 변경되지 않도록 보호

### 장점

- 동시성 문제가 발생하지 않음 (무조건 순차적으로 처리되므로 데이터 무결성 보장)
- 중복 예약이 발생할 가능성이 없음

### 단점

- 성능 저하 가능성 (락이 걸려있는 동안 다른 트랜잭션이 대기해야 함)
- 데드락 위험이 있음

---

## 2. 낙관적 락 (Optimistic Lock)

### 개념

- **[단일노드]**
- **데이터를 변경할 때 다른 트랜잭션이 동시에 변경했는지 검사하는 방식**
- 일반적으로 `version` 컬럼을 사용하여 변경된 데이터가 있는지 확인 후 업데이트 진행

### 장점

- 별도의 데이터 락을 걸지 않으므로 성능이 좋음
- 읽기 위주의 환경에서 유리함

### 단점

- 충돌 발생 시 재시도가 필요함
- 트랜잭션이 많을 경우 충돌 빈도가 증가할 수 있음

---

## 3. 큐 기반 처리 (Queue-Based Processing)

### 개념

- **[단일노드]**
- **예약 요청을 바로 처리하지 않고, 큐에 넣고 순차적으로 처리하는 방식**
- `BullMQ` 같은 메시지 큐를 활용하여 비동기적으로 예약을 처리
- 순차적으로 하나씩 처리하는 큐라면 락이 필요 없음.
- 멀티 워커 환경에서 동시 예약을 처리하는 큐라면 낙관적 락을 고려할 수도 있음.
- 비관적 락은 큐를 사용하는 경우에는 거의 필요 없음.

### 장점

- 대량의 요청을 효율적으로 분산 처리 가능
- 서비스의 부하를 줄이고 안정성을 높일 수 있음

### 단점

- 즉각적인 응답을 받기 어려울 수 있음 (비동기 처리)
- 큐가 쌓이면 지연 시간이 발생할 수 있음

---

## 4. Redis 기반 RedLock 처리 (분산락)

### 개념

- **[다중노드]**
- 분산 락은 공유 자원 자체에 Lock을 설정하는 비관적 락/낙관적 락과 다르게 임계 영역(critical section)에 Lock을 설정한다.
- Redis의 구조가 싱글 스레드의 Multiplexing 기술을 사용해서 원자성 보장에 적합하다.

### 단점

- 공정성을 보장할 수 없다.
- 요청이가 먼저 요청했음에도 락이 걸린 데이터를 요청하게되면 거부된다.

---

## 5. Rabbitmq+Redis 기반 처리

### 개념

- **[다중노드]**
- **메시지 큐와 분산 락을 조합하여 분산 환경에서 안정적인 처리 보장**
- RabbitMQ를 통해 비동기 메시지 처리와 Redis를 통한 분산 락을 함께 사용
- 메시지 큐를 통해 요청을 순차적으로 처리하면서, Redis를 통해 분산 환경에서의 동시성 제어
- RabbitMQ의 지속성과 신뢰성 있는 메시지 전달 + Redis의 빠른 분산 락 처리의 장점을 결합
- 대규모 분산 시스템에서 고성능과 일관성을 동시에 달성 가능

```javascript
useFactory: (configService: ConfigService) => ({
    transport: Transport.RMQ,
    options: {
        urls: [configService.get<string>('RABBITMQ_URL')],
        queue: 'reservation_queue',
        queueOptions: {
            durable: false,
        },
        noAck: false,
        prefetchCount: 1, // SUB에서 1개씩만 처리
    },
}),
```

## 선택 기준

| 방식             | 동시성 보장 | 사용 시점                             |
| ---------------- | ----------- | ------------------------------------- |
| 비관적 락        | ✅ 높음     | 강력한 일관성이 필요할 때             |
| 낙관적 락        | ⚠️ 중간     | 충돌 가능성이 낮을 때                 |
| 큐 기반          | ✅ 높음     | 고성능, 대량 처리 필요할 때           |
| Redis RedLock    | ✅ 높음     | 분산 환경에서 일관성 필요할 때        |
| RabbitMQ + Redis | ✅ 높음     | 분산 환경에서 순서를 보장해야하는경우 |
